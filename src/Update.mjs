// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "rescript/lib/es6/curry.js";
import * as Model from "./Model.mjs";
import * as React from "react";
import * as Collision from "./Collision.mjs";
import * as Caml_array from "rescript/lib/es6/caml_array.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";

function updateState(state, action) {
  if (typeof action === "number") {
    var param = Collision.make(state);
    var vert = param[1];
    var hor = param[0];
    var init = state.ball;
    return {
            rightPlayerY: state.rightPlayerY,
            leftPlayerY: state.leftPlayerY,
            playerWidth: state.playerWidth,
            keys: state.keys,
            game: state.game,
            ball: {
              x: init.x,
              y: init.y,
              size: init.size,
              speed: init.speed,
              horizontalDirection: Belt_Option.mapWithDefault(hor, state.ball.horizontalDirection, (function (param) {
                      return param[0];
                    })),
              verticalDirection: vert !== undefined ? vert : Belt_Option.mapWithDefault(hor, state.ball.verticalDirection, (function (param) {
                        return param[2];
                      })),
              vector: Belt_Option.mapWithDefault(hor, state.ball.vector, (function (param) {
                      return param[1];
                    }))
            },
            fieldLimits: state.fieldLimits,
            playerSize: state.playerSize,
            oldTime: state.oldTime
          };
  }
  switch (action.TAG | 0) {
    case /* UpdateConfig */0 :
        var init$1 = action._0;
        var init$2 = state.ball;
        return {
                rightPlayerY: state.rightPlayerY,
                leftPlayerY: state.leftPlayerY,
                playerWidth: state.playerWidth,
                keys: state.keys,
                game: state.game,
                ball: {
                  x: init$2.x,
                  y: init$2.y,
                  size: init$1.ballSize,
                  speed: init$2.speed,
                  horizontalDirection: init$2.horizontalDirection,
                  verticalDirection: init$2.verticalDirection,
                  vector: init$2.vector
                },
                fieldLimits: {
                  bottom: init$1.fieldHeight,
                  right: init$1.fieldWidth
                },
                playerSize: init$1.playerSize,
                oldTime: state.oldTime
              };
    case /* MovePlayer */1 :
        var player = action._1;
        if (action._0) {
          if (player) {
            return {
                    rightPlayerY: state.rightPlayerY,
                    leftPlayerY: Math.max(state.leftPlayerY - 5, 10),
                    playerWidth: state.playerWidth,
                    keys: state.keys,
                    game: state.game,
                    ball: state.ball,
                    fieldLimits: state.fieldLimits,
                    playerSize: state.playerSize,
                    oldTime: state.oldTime
                  };
          } else {
            return {
                    rightPlayerY: Math.max(state.leftPlayerY - 5, 10),
                    leftPlayerY: state.leftPlayerY,
                    playerWidth: state.playerWidth,
                    keys: state.keys,
                    game: state.game,
                    ball: state.ball,
                    fieldLimits: state.fieldLimits,
                    playerSize: state.playerSize,
                    oldTime: state.oldTime
                  };
          }
        } else if (player) {
          return {
                  rightPlayerY: state.rightPlayerY,
                  leftPlayerY: Math.min(state.leftPlayerY + 5, state.fieldLimits.bottom - state.playerSize + 10),
                  playerWidth: state.playerWidth,
                  keys: state.keys,
                  game: state.game,
                  ball: state.ball,
                  fieldLimits: state.fieldLimits,
                  playerSize: state.playerSize,
                  oldTime: state.oldTime
                };
        } else {
          return {
                  rightPlayerY: Math.min(state.rightPlayerY + 5, state.fieldLimits.bottom - state.playerSize + 10),
                  leftPlayerY: state.leftPlayerY,
                  playerWidth: state.playerWidth,
                  keys: state.keys,
                  game: state.game,
                  ball: state.ball,
                  fieldLimits: state.fieldLimits,
                  playerSize: state.playerSize,
                  oldTime: state.oldTime
                };
        }
    case /* KeyEvent */2 :
        var type_ = action._0;
        switch (action._1) {
          case " " :
              var match = state.game;
              return {
                      rightPlayerY: state.rightPlayerY,
                      leftPlayerY: state.leftPlayerY,
                      playerWidth: state.playerWidth,
                      keys: state.keys,
                      game: match !== 0 ? /* Playing */0 : /* Paused */1,
                      ball: state.ball,
                      fieldLimits: state.fieldLimits,
                      playerSize: state.playerSize,
                      oldTime: state.oldTime
                    };
          case "ArrowDown" :
              var init$3 = state.keys;
              return {
                      rightPlayerY: state.rightPlayerY,
                      leftPlayerY: state.leftPlayerY,
                      playerWidth: state.playerWidth,
                      keys: {
                        arrowUp: init$3.arrowUp,
                        arrowDown: type_ === "keydown"
                      },
                      game: state.game,
                      ball: state.ball,
                      fieldLimits: state.fieldLimits,
                      playerSize: state.playerSize,
                      oldTime: state.oldTime
                    };
          case "ArrowUp" :
              var init$4 = state.keys;
              return {
                      rightPlayerY: state.rightPlayerY,
                      leftPlayerY: state.leftPlayerY,
                      playerWidth: state.playerWidth,
                      keys: {
                        arrowUp: type_ === "keydown",
                        arrowDown: init$4.arrowDown
                      },
                      game: state.game,
                      ball: state.ball,
                      fieldLimits: state.fieldLimits,
                      playerSize: state.playerSize,
                      oldTime: state.oldTime
                    };
          default:
            return state;
        }
    case /* BallMove */3 :
        var progress = action._0;
        var match$1 = state.ball.vector;
        var param$1;
        switch (match$1) {
          case /* Slight */0 :
              param$1 = Caml_array.get(Model.ballVectorTable, 0);
              break;
          case /* Medium */1 :
              param$1 = Caml_array.get(Model.ballVectorTable, 1);
              break;
          case /* Sharp */2 :
              param$1 = Caml_array.get(Model.ballVectorTable, 2);
              break;
          
        }
        var vy = param$1[1];
        var vx = param$1[0];
        var match$2 = state.ball.verticalDirection;
        var match$3 = state.ball.horizontalDirection;
        var match$4 = match$2 ? (
            match$3 ? [
                vx,
                -vy
              ] : [
                -vx | 0,
                -vy
              ]
          ) : (
            match$3 ? [
                vx,
                vy
              ] : [
                -vx | 0,
                vy
              ]
          );
        var init$5 = state.ball;
        return {
                rightPlayerY: state.rightPlayerY,
                leftPlayerY: state.leftPlayerY,
                playerWidth: state.playerWidth,
                keys: state.keys,
                game: state.game,
                ball: {
                  x: Math.max(state.playerWidth, Math.min(state.ball.x + match$4[0] * state.ball.speed * progress, state.fieldLimits.right - state.ball.size - state.playerWidth)),
                  y: Math.max(10, Math.min(state.ball.y + match$4[1] * state.ball.speed * progress, state.fieldLimits.bottom - state.ball.size + 10)),
                  size: init$5.size,
                  speed: init$5.speed,
                  horizontalDirection: init$5.horizontalDirection,
                  verticalDirection: init$5.verticalDirection,
                  vector: init$5.vector
                },
                fieldLimits: state.fieldLimits,
                playerSize: state.playerSize,
                oldTime: state.oldTime
              };
    case /* SetFrameTime */4 :
        return {
                rightPlayerY: state.rightPlayerY,
                leftPlayerY: state.leftPlayerY,
                playerWidth: state.playerWidth,
                keys: state.keys,
                game: state.game,
                ball: state.ball,
                fieldLimits: state.fieldLimits,
                playerSize: state.playerSize,
                oldTime: action._0
              };
    
  }
}

function Update$Tick(Props) {
  var state = Props.state;
  var send = Props.send;
  var tick = function (time) {
    Curry._1(send, {
          TAG: /* SetFrameTime */4,
          _0: time
        });
    var match = state.keys.arrowUp;
    var match$1 = state.keys.arrowDown;
    if (match) {
      if (match$1) {
        
      } else {
        Curry._1(send, {
              TAG: /* MovePlayer */1,
              _0: /* Up */1,
              _1: /* LeftPlayer */1
            });
      }
    } else if (match$1) {
      Curry._1(send, {
            TAG: /* MovePlayer */1,
            _0: /* Down */0,
            _1: /* LeftPlayer */1
          });
    }
    Curry._1(send, /* HandleCollisions */0);
    var progress = (time - state.oldTime) / 15;
    if (progress < 2) {
      return Curry._1(send, {
                  TAG: /* BallMove */3,
                  _0: progress
                });
    }
    
  };
  React.useEffect((function () {
          var match = state.game;
          return Belt_Option.map(match !== 0 ? (console.log(state), undefined) : requestAnimationFrame(tick), (function (timer, param) {
                        cancelAnimationFrame(timer);
                        
                      }));
        }), [
        state.game,
        state,
        tick
      ]);
  return null;
}

var Tick = {
  make: Update$Tick
};

export {
  updateState ,
  Tick ,
  
}
/* react Not a pure module */
