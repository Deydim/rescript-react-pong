// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "rescript/lib/es6/curry.js";
import * as Model from "./Model.mjs";
import * as React from "react";
import * as Collision from "./Collision.mjs";
import * as Caml_array from "rescript/lib/es6/caml_array.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";

function updateState(state, action) {
  if (typeof action === "number") {
    switch (action) {
      case /* PlayerUp */0 :
          return {
                  rightPlayerY: Math.max(state.rightPlayerY - 5, 10),
                  leftPlayerY: Math.max(state.leftPlayerY - 5, 10),
                  playerWidth: state.playerWidth,
                  keys: state.keys,
                  game: state.game,
                  horizontalCollision: state.horizontalCollision,
                  ball: state.ball,
                  fieldLimits: state.fieldLimits,
                  playerSize: state.playerSize,
                  oldTime: state.oldTime
                };
      case /* PlayerDown */1 :
          return {
                  rightPlayerY: Math.min(state.rightPlayerY + 5, state.fieldLimits.bottom - state.playerSize + 10),
                  leftPlayerY: Math.min(state.leftPlayerY + 5, state.fieldLimits.bottom - state.playerSize + 10),
                  playerWidth: state.playerWidth,
                  keys: state.keys,
                  game: state.game,
                  horizontalCollision: state.horizontalCollision,
                  ball: state.ball,
                  fieldLimits: state.fieldLimits,
                  playerSize: state.playerSize,
                  oldTime: state.oldTime
                };
      case /* Start */2 :
          return {
                  rightPlayerY: state.rightPlayerY,
                  leftPlayerY: state.leftPlayerY,
                  playerWidth: state.playerWidth,
                  keys: state.keys,
                  game: /* Playing */0,
                  horizontalCollision: state.horizontalCollision,
                  ball: state.ball,
                  fieldLimits: state.fieldLimits,
                  playerSize: state.playerSize,
                  oldTime: state.oldTime
                };
      case /* Pause */3 :
          return {
                  rightPlayerY: state.rightPlayerY,
                  leftPlayerY: state.leftPlayerY,
                  playerWidth: state.playerWidth,
                  keys: state.keys,
                  game: /* Paused */2,
                  horizontalCollision: state.horizontalCollision,
                  ball: state.ball,
                  fieldLimits: state.fieldLimits,
                  playerSize: state.playerSize,
                  oldTime: state.oldTime
                };
      case /* HandleCollisions */4 :
          var param = Collision.make(state);
          var init = state.ball;
          return {
                  rightPlayerY: state.rightPlayerY,
                  leftPlayerY: state.leftPlayerY,
                  playerWidth: state.playerWidth,
                  keys: state.keys,
                  game: state.game,
                  horizontalCollision: state.horizontalCollision,
                  ball: {
                    x: init.x,
                    y: init.y,
                    size: init.size,
                    speed: init.speed,
                    horizontalDirection: Belt_Option.getWithDefault(param[0], state.ball.horizontalDirection),
                    verticalDirection: Belt_Option.getWithDefault(param[1], state.ball.verticalDirection),
                    vectorIndex: init.vectorIndex
                  },
                  fieldLimits: state.fieldLimits,
                  playerSize: state.playerSize,
                  oldTime: state.oldTime
                };
      
    }
  } else {
    switch (action.TAG | 0) {
      case /* UpdateConfig */0 :
          var init$1 = action._0;
          var init$2 = state.ball;
          return {
                  rightPlayerY: state.rightPlayerY,
                  leftPlayerY: state.leftPlayerY,
                  playerWidth: state.playerWidth,
                  keys: state.keys,
                  game: state.game,
                  horizontalCollision: state.horizontalCollision,
                  ball: {
                    x: init$2.x,
                    y: init$2.y,
                    size: init$1.ballSize,
                    speed: init$2.speed,
                    horizontalDirection: init$2.horizontalDirection,
                    verticalDirection: init$2.verticalDirection,
                    vectorIndex: init$2.vectorIndex
                  },
                  fieldLimits: {
                    bottom: init$1.fieldHeight,
                    right: init$1.fieldWidth
                  },
                  playerSize: init$1.playerSize,
                  oldTime: state.oldTime
                };
      case /* KeyEvent */1 :
          var type_ = action._0;
          switch (action._1) {
            case " " :
                return {
                        rightPlayerY: state.rightPlayerY,
                        leftPlayerY: state.leftPlayerY,
                        playerWidth: state.playerWidth,
                        keys: state.keys,
                        game: state.game === /* Paused */2 ? /* Playing */0 : /* Paused */2,
                        horizontalCollision: state.horizontalCollision,
                        ball: state.ball,
                        fieldLimits: state.fieldLimits,
                        playerSize: state.playerSize,
                        oldTime: state.oldTime
                      };
            case "ArrowDown" :
                var init$3 = state.keys;
                return {
                        rightPlayerY: state.rightPlayerY,
                        leftPlayerY: state.leftPlayerY,
                        playerWidth: state.playerWidth,
                        keys: {
                          arrowUp: init$3.arrowUp,
                          arrowDown: type_ === "keydown"
                        },
                        game: state.game,
                        horizontalCollision: state.horizontalCollision,
                        ball: state.ball,
                        fieldLimits: state.fieldLimits,
                        playerSize: state.playerSize,
                        oldTime: state.oldTime
                      };
            case "ArrowUp" :
                var init$4 = state.keys;
                return {
                        rightPlayerY: state.rightPlayerY,
                        leftPlayerY: state.leftPlayerY,
                        playerWidth: state.playerWidth,
                        keys: {
                          arrowUp: type_ === "keydown",
                          arrowDown: init$4.arrowDown
                        },
                        game: state.game,
                        horizontalCollision: state.horizontalCollision,
                        ball: state.ball,
                        fieldLimits: state.fieldLimits,
                        playerSize: state.playerSize,
                        oldTime: state.oldTime
                      };
            default:
              return state;
          }
      case /* BallMove */2 :
          var progress = action._0;
          var param$1 = Caml_array.get(Model.ballVectorTable, state.ball.vectorIndex);
          var vy = param$1[1];
          var vx = param$1[0];
          var match = state.ball.verticalDirection;
          var match$1 = state.ball.horizontalDirection;
          var match$2 = match ? (
              match$1 ? [
                  vx,
                  -vy
                ] : [
                  -vx | 0,
                  -vy
                ]
            ) : (
              match$1 ? [
                  vx,
                  vy
                ] : [
                  -vx | 0,
                  vy
                ]
            );
          var init$5 = state.ball;
          return {
                  rightPlayerY: state.rightPlayerY,
                  leftPlayerY: state.leftPlayerY,
                  playerWidth: state.playerWidth,
                  keys: state.keys,
                  game: state.game,
                  horizontalCollision: state.horizontalCollision,
                  ball: {
                    x: Math.max(state.playerWidth, Math.min(state.ball.x + match$2[0] * state.ball.speed * progress, state.fieldLimits.right - state.ball.size - state.playerWidth)),
                    y: Math.max(10, Math.min(state.ball.y + match$2[1] * state.ball.speed * progress, state.fieldLimits.bottom - state.ball.size + 10)),
                    size: init$5.size,
                    speed: init$5.speed,
                    horizontalDirection: init$5.horizontalDirection,
                    verticalDirection: init$5.verticalDirection,
                    vectorIndex: init$5.vectorIndex
                  },
                  fieldLimits: state.fieldLimits,
                  playerSize: state.playerSize,
                  oldTime: state.oldTime
                };
      case /* SetFrameTime */3 :
          return {
                  rightPlayerY: state.rightPlayerY,
                  leftPlayerY: state.leftPlayerY,
                  playerWidth: state.playerWidth,
                  keys: state.keys,
                  game: state.game,
                  horizontalCollision: state.horizontalCollision,
                  ball: state.ball,
                  fieldLimits: state.fieldLimits,
                  playerSize: state.playerSize,
                  oldTime: action._0
                };
      
    }
  }
}

function Update$Tick(Props) {
  var state = Props.state;
  var dispatch = Props.dispatch;
  var tick = function (time) {
    Curry._1(dispatch, {
          TAG: /* SetFrameTime */3,
          _0: time
        });
    var match = state.keys.arrowUp;
    var match$1 = state.keys.arrowDown;
    if (match) {
      if (match$1) {
        
      } else {
        Curry._1(dispatch, /* PlayerUp */0);
      }
    } else if (match$1) {
      Curry._1(dispatch, /* PlayerDown */1);
    }
    Curry._1(dispatch, /* HandleCollisions */4);
    var progress = (time - state.oldTime) / 15;
    if (progress < 2) {
      return Curry._1(dispatch, {
                  TAG: /* BallMove */2,
                  _0: progress
                });
    }
    
  };
  React.useEffect((function () {
          var match = state.game;
          return Belt_Option.map(match !== 0 ? (console.log(state), undefined) : requestAnimationFrame(tick), (function (timer, param) {
                        cancelAnimationFrame(timer);
                        
                      }));
        }), [
        state.oldTime,
        state.game
      ]);
  return null;
}

var Tick = {
  make: Update$Tick
};

export {
  updateState ,
  Tick ,
  
}
/* react Not a pure module */
