// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "rescript/lib/es6/curry.js";
import * as Model from "./Model.mjs";
import * as React from "react";
import * as Collision from "./Collision.mjs";
import * as Caml_array from "rescript/lib/es6/caml_array.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";

function updateState(state, action) {
  if (typeof action === "number") {
    switch (action) {
      case /* Start */0 :
          return {
                  rightPlayerY: state.rightPlayerY,
                  leftPlayerY: state.leftPlayerY,
                  playerWidth: state.playerWidth,
                  keys: state.keys,
                  game: /* Playing */0,
                  horizontalCollision: state.horizontalCollision,
                  ball: state.ball,
                  fieldLimits: state.fieldLimits,
                  playerSize: state.playerSize,
                  oldTime: state.oldTime
                };
      case /* Pause */1 :
          return {
                  rightPlayerY: state.rightPlayerY,
                  leftPlayerY: state.leftPlayerY,
                  playerWidth: state.playerWidth,
                  keys: state.keys,
                  game: /* Paused */1,
                  horizontalCollision: state.horizontalCollision,
                  ball: state.ball,
                  fieldLimits: state.fieldLimits,
                  playerSize: state.playerSize,
                  oldTime: state.oldTime
                };
      case /* HandleCollisions */2 :
          var param = Collision.make(state);
          var vert = param[1];
          var hor = param[0];
          var init = state.ball;
          return {
                  rightPlayerY: state.rightPlayerY,
                  leftPlayerY: state.leftPlayerY,
                  playerWidth: state.playerWidth,
                  keys: state.keys,
                  game: state.game,
                  horizontalCollision: state.horizontalCollision,
                  ball: {
                    x: init.x,
                    y: init.y,
                    size: init.size,
                    speed: init.speed,
                    horizontalDirection: Belt_Option.mapWithDefault(hor, state.ball.horizontalDirection, (function (param) {
                            return param[0];
                          })),
                    verticalDirection: vert !== undefined ? vert : Belt_Option.mapWithDefault(hor, state.ball.verticalDirection, (function (param) {
                              return param[1][1];
                            })),
                    vector: Belt_Option.mapWithDefault(hor, state.ball.vector, (function (param) {
                            return param[1][0];
                          }))
                  },
                  fieldLimits: state.fieldLimits,
                  playerSize: state.playerSize,
                  oldTime: state.oldTime
                };
      
    }
  } else {
    switch (action.TAG | 0) {
      case /* MovePlayer */0 :
          if (action._0) {
            return {
                    rightPlayerY: Math.max(state.rightPlayerY - 5, 10),
                    leftPlayerY: Math.max(state.leftPlayerY - 5, 10),
                    playerWidth: state.playerWidth,
                    keys: state.keys,
                    game: state.game,
                    horizontalCollision: state.horizontalCollision,
                    ball: state.ball,
                    fieldLimits: state.fieldLimits,
                    playerSize: state.playerSize,
                    oldTime: state.oldTime
                  };
          } else {
            return {
                    rightPlayerY: Math.min(state.rightPlayerY + 5, state.fieldLimits.bottom - state.playerSize + 10),
                    leftPlayerY: Math.min(state.leftPlayerY + 5, state.fieldLimits.bottom - state.playerSize + 10),
                    playerWidth: state.playerWidth,
                    keys: state.keys,
                    game: state.game,
                    horizontalCollision: state.horizontalCollision,
                    ball: state.ball,
                    fieldLimits: state.fieldLimits,
                    playerSize: state.playerSize,
                    oldTime: state.oldTime
                  };
          }
      case /* UpdateConfig */1 :
          var init$1 = action._0;
          var init$2 = state.ball;
          return {
                  rightPlayerY: state.rightPlayerY,
                  leftPlayerY: state.leftPlayerY,
                  playerWidth: state.playerWidth,
                  keys: state.keys,
                  game: state.game,
                  horizontalCollision: state.horizontalCollision,
                  ball: {
                    x: init$2.x,
                    y: init$2.y,
                    size: init$1.ballSize,
                    speed: init$2.speed,
                    horizontalDirection: init$2.horizontalDirection,
                    verticalDirection: init$2.verticalDirection,
                    vector: init$2.vector
                  },
                  fieldLimits: {
                    bottom: init$1.fieldHeight,
                    right: init$1.fieldWidth
                  },
                  playerSize: init$1.playerSize,
                  oldTime: state.oldTime
                };
      case /* KeyEvent */2 :
          var type_ = action._0;
          switch (action._1) {
            case " " :
                return {
                        rightPlayerY: state.rightPlayerY,
                        leftPlayerY: state.leftPlayerY,
                        playerWidth: state.playerWidth,
                        keys: state.keys,
                        game: state.game === /* Paused */1 ? /* Playing */0 : /* Paused */1,
                        horizontalCollision: state.horizontalCollision,
                        ball: state.ball,
                        fieldLimits: state.fieldLimits,
                        playerSize: state.playerSize,
                        oldTime: state.oldTime
                      };
            case "ArrowDown" :
                var init$3 = state.keys;
                return {
                        rightPlayerY: state.rightPlayerY,
                        leftPlayerY: state.leftPlayerY,
                        playerWidth: state.playerWidth,
                        keys: {
                          arrowUp: init$3.arrowUp,
                          arrowDown: type_ === "keydown"
                        },
                        game: state.game,
                        horizontalCollision: state.horizontalCollision,
                        ball: state.ball,
                        fieldLimits: state.fieldLimits,
                        playerSize: state.playerSize,
                        oldTime: state.oldTime
                      };
            case "ArrowUp" :
                var init$4 = state.keys;
                return {
                        rightPlayerY: state.rightPlayerY,
                        leftPlayerY: state.leftPlayerY,
                        playerWidth: state.playerWidth,
                        keys: {
                          arrowUp: type_ === "keydown",
                          arrowDown: init$4.arrowDown
                        },
                        game: state.game,
                        horizontalCollision: state.horizontalCollision,
                        ball: state.ball,
                        fieldLimits: state.fieldLimits,
                        playerSize: state.playerSize,
                        oldTime: state.oldTime
                      };
            default:
              return state;
          }
      case /* BallMove */3 :
          var progress = action._0;
          var match = state.ball.vector;
          var param$1;
          switch (match) {
            case /* Slight */0 :
                param$1 = Caml_array.get(Model.ballVectorTable, 0);
                break;
            case /* Medium */1 :
                param$1 = Caml_array.get(Model.ballVectorTable, 1);
                break;
            case /* Sharp */2 :
                param$1 = Caml_array.get(Model.ballVectorTable, 2);
                break;
            
          }
          var vy = param$1[1];
          var vx = param$1[0];
          var match$1 = state.ball.verticalDirection;
          var match$2 = state.ball.horizontalDirection;
          var match$3 = match$1 ? (
              match$2 ? [
                  vx,
                  -vy
                ] : [
                  -vx | 0,
                  -vy
                ]
            ) : (
              match$2 ? [
                  vx,
                  vy
                ] : [
                  -vx | 0,
                  vy
                ]
            );
          var init$5 = state.ball;
          return {
                  rightPlayerY: state.rightPlayerY,
                  leftPlayerY: state.leftPlayerY,
                  playerWidth: state.playerWidth,
                  keys: state.keys,
                  game: state.game,
                  horizontalCollision: state.horizontalCollision,
                  ball: {
                    x: Math.max(state.playerWidth, Math.min(state.ball.x + match$3[0] * state.ball.speed * progress, state.fieldLimits.right - state.ball.size - state.playerWidth)),
                    y: Math.max(10, Math.min(state.ball.y + match$3[1] * state.ball.speed * progress, state.fieldLimits.bottom - state.ball.size + 10)),
                    size: init$5.size,
                    speed: init$5.speed,
                    horizontalDirection: init$5.horizontalDirection,
                    verticalDirection: init$5.verticalDirection,
                    vector: init$5.vector
                  },
                  fieldLimits: state.fieldLimits,
                  playerSize: state.playerSize,
                  oldTime: state.oldTime
                };
      case /* SetFrameTime */4 :
          return {
                  rightPlayerY: state.rightPlayerY,
                  leftPlayerY: state.leftPlayerY,
                  playerWidth: state.playerWidth,
                  keys: state.keys,
                  game: state.game,
                  horizontalCollision: state.horizontalCollision,
                  ball: state.ball,
                  fieldLimits: state.fieldLimits,
                  playerSize: state.playerSize,
                  oldTime: action._0
                };
      
    }
  }
}

function Update$Tick(Props) {
  var state = Props.state;
  var dispatch = Props.dispatch;
  var tick = function (time) {
    Curry._1(dispatch, {
          TAG: /* SetFrameTime */4,
          _0: time
        });
    var match = state.keys.arrowUp;
    var match$1 = state.keys.arrowDown;
    if (match) {
      if (match$1) {
        
      } else {
        Curry._1(dispatch, {
              TAG: /* MovePlayer */0,
              _0: /* Up */1
            });
      }
    } else if (match$1) {
      Curry._1(dispatch, {
            TAG: /* MovePlayer */0,
            _0: /* Down */0
          });
    }
    Curry._1(dispatch, /* HandleCollisions */2);
    var progress = (time - state.oldTime) / 15;
    if (progress < 2) {
      return Curry._1(dispatch, {
                  TAG: /* BallMove */3,
                  _0: progress
                });
    }
    
  };
  React.useEffect((function () {
          var match = state.game;
          return Belt_Option.map(match ? (console.log(state), undefined) : requestAnimationFrame(tick), (function (timer, param) {
                        cancelAnimationFrame(timer);
                        
                      }));
        }), [
        state.oldTime,
        state.game,
        state,
        tick
      ]);
  return null;
}

var Tick = {
  make: Update$Tick
};

export {
  updateState ,
  Tick ,
  
}
/* react Not a pure module */
