// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Model from "./Model.mjs";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";

function make(collision, param) {
  var match = param.fieldLimits;
  var fieldWidth = match.right;
  var fieldHeight = match.bottom;
  var match$1 = param.ball;
  var size = match$1.size;
  var playerWidth = param.playerWidth;
  var match$2 = Model.getVector(Belt_Option.getWithDefault(collision.playerVector, match$1.vector));
  var vy = match$2[1];
  var vx = match$2[0];
  var x = match$1.x;
  var y = match$1.y;
  var left = Caml_obj.caml_equal(collision.horizontalDirection, /* Left */0) ? -1 : 1;
  var up = Caml_obj.caml_equal(collision.playerVertical, /* Up */1) ? -1 : 1;
  while(x >= playerWidth && x < fieldWidth - playerWidth) {
    x = x + vx * left;
    y = y + vy * up;
    if (y < 10) {
      y = 10;
      up = -up;
    }
    if (y > fieldHeight - size + 10) {
      y = fieldHeight - size + 10;
      up = -up;
    }
    
  };
  return y + Math.round(param.playerSize / 2 * Math.random() - 4) * (
          Math.random() < 0.5 ? -1 : 1
        );
}

var PredictBallHit = {
  make: make
};

function make$1(collision, param) {
  var match = param.ball;
  var ballSize = match.size;
  var playerWidth = param.playerWidth;
  var ballCenterX = match.x + ballSize / 2;
  var leftPlayerCenterX = playerWidth / 2;
  var rightPlayerCenterX = param.fieldLimits.right - playerWidth / 2;
  var limit = ballSize / 2 + playerWidth / 2;
  if (match.horizontalDirection) {
    return {
            horizontalDirection: rightPlayerCenterX - ballCenterX === limit ? /* Right */1 : undefined,
            wallsVertical: collision.wallsVertical,
            playerVector: collision.playerVector,
            playerVertical: collision.playerVertical,
            predictedY: collision.predictedY
          };
  } else {
    return {
            horizontalDirection: ballCenterX - leftPlayerCenterX === limit ? /* Left */0 : undefined,
            wallsVertical: collision.wallsVertical,
            playerVector: collision.playerVector,
            playerVertical: collision.playerVertical,
            predictedY: collision.predictedY
          };
  }
}

var Broad = {
  make: make$1
};

function make$2(collision, state) {
  var ballCenter = state.ball.y + state.ball.size / 2;
  var playerY = state.ball.horizontalDirection === /* Left */0 ? state.leftPlayerY : state.rightPlayerY;
  var playerCenter = playerY + state.playerSize / 2;
  var hit = (ballCenter - playerCenter) / state.playerSize / 3 * 10;
  var match = Math.round(Math.abs(hit));
  return {
          horizontalDirection: collision.horizontalDirection,
          wallsVertical: collision.wallsVertical,
          playerVector: match !== 0 ? (
              match !== 1 ? (
                  match !== 2 ? undefined : /* Sharp */2
                ) : /* Medium */1
            ) : /* Slight */0,
          playerVertical: hit < 0 ? /* Up */1 : (
              hit > 0 ? /* Down */0 : (
                  hit === 0 ? state.ball.verticalDirection : undefined
                )
            ),
          predictedY: collision.predictedY
        };
}

var VectorChange = {
  make: make$2
};

function make$3(collision, state) {
  var playerSize = state.playerSize;
  var match = state.ball;
  var ballSize = match.size;
  var ballY = match.y;
  var leftPlayerY = state.leftPlayerY;
  var rightPlayerY = state.rightPlayerY;
  var match$1 = collision.horizontalDirection;
  return {
          horizontalDirection: match$1 !== undefined ? (
              match$1 ? (
                  ballY + ballSize > rightPlayerY && ballY < rightPlayerY + playerSize ? /* Left */0 : undefined
                ) : (
                  ballY + ballSize > leftPlayerY && ballY < leftPlayerY + playerSize ? /* Right */1 : undefined
                )
            ) : undefined,
          wallsVertical: collision.wallsVertical,
          playerVector: collision.playerVector,
          playerVertical: collision.playerVertical,
          predictedY: collision.predictedY
        };
}

var Narrow = {
  make: make$3
};

function make$4(param) {
  var match = param.ball;
  var ballY = match.y;
  if (ballY === 10 || ballY === param.fieldLimits.bottom - match.size + 10) {
    if (match.verticalDirection === /* Down */0) {
      return /* Up */1;
    } else {
      return /* Down */0;
    }
  }
  
}

var Walls = {
  make: make$4
};

function make$5(state) {
  var collision_wallsVertical = make$4(state);
  var collision = {
    horizontalDirection: undefined,
    wallsVertical: collision_wallsVertical,
    playerVector: undefined,
    playerVertical: undefined,
    predictedY: undefined
  };
  var match = collision_wallsVertical;
  if (match !== undefined) {
    return collision;
  }
  var collision$1 = make$1(collision, state);
  var match$1 = collision$1.horizontalDirection;
  if (match$1 === undefined) {
    return collision$1;
  }
  var collision$2 = make$3(collision$1, state);
  var match$2 = collision$2.horizontalDirection;
  if (match$2 === undefined) {
    return collision$2;
  }
  var collision$3 = make$2(collision$2, state);
  return {
          horizontalDirection: collision$3.horizontalDirection,
          wallsVertical: collision$3.wallsVertical,
          playerVector: collision$3.playerVector,
          playerVertical: collision$3.playerVertical,
          predictedY: make(collision$3, state)
        };
}

export {
  PredictBallHit ,
  Broad ,
  VectorChange ,
  Narrow ,
  Walls ,
  make$5 as make,
  
}
/* No side effect */
