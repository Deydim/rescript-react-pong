// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Js_exn from "rescript/lib/es6/js_exn.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";

function make(param) {
  var match = param.ball;
  var ballSize = match.size;
  var playerWidth = param.playerWidth;
  var ballCenterX = match.x + ballSize / 2;
  var leftPlayerCenterX = playerWidth / 2;
  var rightPlayerCenterX = param.fieldLimits.right - playerWidth / 2;
  var limit = ballSize / 2 + playerWidth / 2;
  if (match.horizontalDirection) {
    if (rightPlayerCenterX - ballCenterX === limit) {
      return /* Right */1;
    } else {
      return ;
    }
  } else if (ballCenterX - leftPlayerCenterX === limit) {
    return /* Left */0;
  } else {
    return ;
  }
}

var Broad = {
  make: make
};

function make$1(ballSize, ballY, playerY, playerSize, ballVertDir) {
  var ballCenter = ballY + ballSize / 2;
  var playerCenter = playerY + playerSize / 2;
  var hit = (ballCenter - playerCenter) / playerSize / 3 * 10;
  var dir = hit < 0 ? /* Up */1 : (
      hit > 0 ? /* Down */0 : (
          hit === 0 ? ballVertDir : Js_exn.raiseError("This state should be impossible!")
        )
    );
  var match = Math.round(Math.abs(hit));
  if (match !== 0) {
    if (match !== 1) {
      if (match !== 2) {
        return Js_exn.raiseError("Illegal player vs ball collision state!");
      } else {
        return [
                /* Sharp */2,
                dir
              ];
      }
    } else {
      return [
              /* Medium */1,
              dir
            ];
    }
  } else {
    return [
            /* Slight */0,
            dir
          ];
  }
}

var VectorChange = {
  make: make$1
};

function make$2(dir, state) {
  var playerSize = state.playerSize;
  var match = state.ball;
  var ballSize = match.size;
  var ballY = match.y;
  var leftPlayerY = state.leftPlayerY;
  var rightPlayerY = state.rightPlayerY;
  if (dir) {
    if (ballY + ballSize > rightPlayerY && ballY < rightPlayerY + playerSize) {
      return [
              /* Left */0,
              make$1(ballSize, ballY, rightPlayerY, playerSize, state.ball.verticalDirection)
            ];
    } else {
      return ;
    }
  } else if (ballY + ballSize > leftPlayerY && ballY < leftPlayerY + playerSize) {
    return [
            /* Right */1,
            make$1(ballSize, ballY, leftPlayerY, playerSize, state.ball.verticalDirection)
          ];
  } else {
    return ;
  }
}

var Narrow = {
  make: make$2
};

function make$3(param) {
  var match = param.ball;
  var ballY = match.y;
  if (ballY === 10 || ballY === param.fieldLimits.bottom - match.size + 10) {
    if (match.verticalDirection === /* Down */0) {
      return /* Up */1;
    } else {
      return /* Down */0;
    }
  }
  
}

var Walls = {
  make: make$3
};

function make$4(state) {
  return [
          Belt_Option.flatMap(make(state), (function (dir) {
                  return Belt_Option.map(make$2(dir, state), (function (param) {
                                var match = param[1];
                                return [
                                        param[0],
                                        match[0],
                                        match[1]
                                      ];
                              }));
                })),
          make$3(state)
        ];
}

export {
  Broad ,
  VectorChange ,
  Narrow ,
  Walls ,
  make$4 as make,
  
}
/* No side effect */
